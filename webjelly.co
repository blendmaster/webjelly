# Webjelly
# Author: Steven Ruppert
# For the Fall 2012 CSCI441 Graphics class at Colorado School of Mines

# this comment appears in the compiled source:
/* This file (webjelly.js) is compiled from webjelly.co. Please view the
original commented source there. */

"use strict"

canvas = document.getElementById \canvas
{width, height} = canvas

try
  window.gl = WebGLDebugUtils.makeDebugContext do
    canvas.getContext \webgl or canvas.getContext \experimental-webgl

if gl!?
  alert "Sorry, it looks like your browser doesn't support WebGL, or webGL is
    disabled!"
  throw new Error "no webgl ;_;"

# I don't like typing in gl all the time, so I will attach CONSTANTS to the
# global context. Don't do this at home, kids.
for k, v in gl
  window[k] = v if /^[A-Z_]+$/.test k

# grab control state and setup listeners
#var shading

#$ \flat
  #if &checked
    #shading = \flat
  #&addEventListener \click !->
    #shading := \flat
    #do draw

#$ \gouraud
  #if &checked
    #shading = \gouraud
  #&addEventListener \click !->
    #shading := \gouraud
    #do draw

# swap culling
$ \front
  if &checked
    gl.cullFace FRONT
  &addEventListener \click !->
    gl.cullFace FRONT
    do draw
$ \back
  if &checked
    gl.cullFace BACK
  &addEventListener \click !->
    gl.cullFace BACK
    do draw

# zooming
var fov
$ \zoom-in .addEventListener \click !->
  --fov
  do draw
$ \zoom-out .addEventListener \click !->
  ++fov
  do draw

# set up
gl
  &viewport   0 0 width, height

  &enable    DEPTH_TEST

  &enable     CULL_FACE

  &clearColor 0 0 0 1 # black
  &clear      COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

with gl
  vertex-shader = @createShader VERTEX_SHADER
    @shaderSource (&), """
      attribute vec3 coord;
      attribute vec3 normal;

      varying float NdotL;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;
      uniform mat3 NormalMatrix;
      uniform vec3 LightLocation;

      void main() {
        vec4 WorldCoord = ModelViewMatrix * vec4(coord,1.0);   // convert to world coordinates
        vec3 L = normalize(LightLocation - WorldCoord.xyz);    // L vector for illumination
        vec3 WorldNormal = NormalMatrix * normal;                // normal in world coordinates
        vec3 N = normalize(WorldNormal);                       // N vector for illumination
        NdotL = dot(N,L);                                      // part of diffuse term (multiplied by k_d's etc in the fragment shader)
        gl_Position = ProjectionMatrix * WorldCoord;             // gl_Position is a predefined variable
          // a correctly written vertex shader should write screen space coordinates to gl_Position
          // they are used on the rasterization stage!
      }
    """
    @compileShader (&)
    unless @getShaderParameter (&), COMPILE_STATUS
      throw new Error "couldn't compile vertex shader!"

  fragment-shader = @createShader FRAGMENT_SHADER
    @shaderSource (&), """
      precision mediump float;

      varying float NdotL;   // interpolated NdotL values (output of the vertex shader!)
      // note that interpolation qualifiers have to match between vertex and fragment shader

      uniform float LightIntensity;
      uniform float AmbientIntensity;
      uniform vec3 DiffuseAndAmbientCoefficient;     // for RGB: this is why it's a 3D vector

      void main() {
        gl_FragColor = vec4(
          (LightIntensity * (NdotL > 0.0 ? NdotL : 0.0) + AmbientIntensity) *
          DiffuseAndAmbientCoefficient,
          1);
        // note that some simplifying assumptions are made in the above formula
        //  for example, k_a=k_d is used; also, specular term is not used; also, no attenuation here
      }
    """
    @compileShader(&)
    unless @getShaderParameter (&), COMPILE_STATUS
      throw new Error "couldn't compile fragment shader!"

  window.program = @createProgram!
    @attachShader (&), vertex-shader
    @attachShader (&), fragment-shader
    @linkProgram (&)
    unless @getProgramParameter (&), LINK_STATUS
      throw new Error "couldn't intialize shader program!"
    @useProgram (&)

  # bind lightsource information

  @uniform1f do
    @getUniformLocation program, \LightIntensity
    0.9

  @uniform1f do
    @getUniformLocation program, \AmbientIntensity
    0.1

  @uniform3f do
    @getUniformLocation program, \DiffuseAndAmbientCoefficient
    1.0 1.0 1.0

  @uniform3f do
    @getUniformLocation program, \LightLocation
    -200 200 200

calculate-normals = ->
  #flat = new Float32Array vertices.length
  gouraud = new Float32Array vertices.length

  for i from 0 to triangles.length - 3 by 3
    a = triangles[i    ] * 3
    b = triangles[i + 1] * 3
    c = triangles[i + 2] * 3
    v0 = Array::slice.call vertices, a, 3 + a
    v1 = Array::slice.call vertices, b, 3 + b
    v2 = Array::slice.call vertices, c, 3 + c

    cross = vec3.cross do
      vec3.direction v0, v1, []
      vec3.direction v0, v2, []
      []

    gouraud[a    ] += cross[0]
    gouraud[a + 1] += cross[1]
    gouraud[a + 2] += cross[2]

    gouraud[b    ] += cross[0]
    gouraud[b + 1] += cross[1]
    gouraud[b + 2] += cross[2]

    gouraud[c    ] += cross[0]
    gouraud[c + 1] += cross[1]
    gouraud[c + 2] += cross[2]

    # first to file for flat
    #if flat[a] is 0
      #flat[a    ] = cross[0]
      #flat[a + 1] = cross[1]
      #flat[a + 2] = cross[2]
    #if flat[b] is 0
      #flat[b    ] = cross[0]
      #flat[b + 1] = cross[1]
      #flat[b + 2] = cross[2]
    #if flat[c] is 0
      #flat[c    ] = cross[0]
      #flat[c + 1] = cross[1]
      #flat[c + 2] = cross[2]

  return gouraud

var triangles, vertices
var vertices-buffer, normals-buffer, triangles-buffer
var staging
var distance, rotation, current-rot

# draw the model from the input file of triangles and vertices
setup-buffers = !->

  gouraud = do calculate-normals
  log "normals: #gouraud"

  # find coordinate bounds
  minx = miny = minz = Infinity
  maxx = maxy = maxz = 0
  for i from 0 to vertices.length - 3 by 3
    vertices[i]
      minx <?= &
      maxx >?= &
    vertices[i + 1]
      miny <?= &
      maxy >?= &
    vertices[i + 2]
      minz <?= &
      maxz >?= &

  log "min: #minx #miny #minz"
  log "max: #maxx #maxy #maxz"

  # transforms to center stage
  to-center =
    -[(minx + maxx) / 2, (miny + maxy) / 2, (minz + maxz) / 2]
    |> mat4.translate mat4.identity!, _

  to-stage =
    Math.max(maxx - minx, maxz - miny, maxz - minz)
    |> 2 / _
    |> log [_, _, _]
    |> mat4.scale mat4.identity!, _

  staging := mat4.multiply to-center, to-stage, mat4.create!

  # vertices
  vertices-buffer := gl.createBuffer!
    gl.bindBuffer ARRAY_BUFFER, (&)
    gl.bufferData ARRAY_BUFFER, vertices, STATIC_DRAW

    # bind to varying coordiantes
    gl.getAttribLocation program, \coord
      gl.enableVertexAttribArray (&)
      gl.vertexAttribPointer (&), 3, FLOAT, false 0 0

  # normals
  normals-buffer := gl.createBuffer!
    gl.bindBuffer ELEMENT_ARRAY_BUFFER, (&)
    gl.bufferData ELEMENT_ARRAY_BUFFER, gouraud, STATIC_DRAW

    # bind to varying normal
    gl.getAttribLocation program, \normal
      gl.enableVertexAttribArray (&)
      gl.vertexAttribPointer (&), 3, FLOAT, false 0 0

  console.log triangles
  triangles-buffer := gl.createBuffer!
    gl.bindBuffer ELEMENT_ARRAY_BUFFER, (&)
    gl.bufferData ELEMENT_ARRAY_BUFFER, triangles, STATIC_DRAW

  rotation := mat4.identity!
  current-rot := mat4.identity!
  fov := 15deg
  distance := 1 / Math.tan(radians(fov) / 2)


export draw = !->
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  rot = mat4.multiply do
    rotation
    current-rot
    mat4.create!

  gl.uniformMatrix4fv do
    gl.getUniformLocation program, \ProjectionMatrix
    false
    mat4.perspective do
      fov
      1 # width / height
      distance - 1
      distance + 10

  # set matrix uniforms
  gl.uniformMatrix3fv do
    gl.getUniformLocation program, \NormalMatrix
    false
    mat4.toMat3 rot

  model-view = mat4.identity!
  mat4.multiply do
    model-view
    #mat4.translate mat4.identity!, [0,-1, -15]
    mat4.translate mat4.identity!, [0,0, -(distance + 1)]
  mat4.multiply model-view, rot
  mat4.multiply model-view, staging

  gl.uniformMatrix4fv do
    gl.getUniformLocation program, \ModelViewMatrix
    false
    model-view

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, triangles-buffer
  gl.drawElements TRIANGLES, triangles.length, UNSIGNED_SHORT, 0

# read the input file
parse = !->
  if @files.0
    new FileReader
      &readAsText that
      &onload = !->
        tokens = @result.split /\s+/ .map parseFloat
        [num-triangles, num-vertices] = tokens.splice 0, 2

        triangles := new Uint16Array tokens.splice 0 num-triangles * 3
        vertices := new Float32Array tokens.splice 0 num-vertices * 3

        do setup-buffers
        do draw

$ \file
  &addEventListener \change parse
  # on refresh, if some file is still selected, do parse
  parse.call (&)

point-under = (x,y) ->
  {left, top} = canvas.getBoundingClientRect!

  # normalize to [-1, 1]
  x = (x - left) * 2 / (width - 1) - 1
  y = -((y - top) * 2 / (height - 1) - 1)

  det = 1 - x*x - y*y

  if det >= 0
    [x, y, Math.sqrt det]
  else
    [x / Math.sqrt(x*x + y*y), y / Math.sqrt(x*x + y*y), 0]

# mouse rotation
canvas
  &addEventListener \mousedown !({clientX: i0, clientY: j0}) ->
    &style.cursor = \move

    p = point-under i0, j0

    rotate = !({clientX: i, clientY: j}) ->
      q = point-under i, j
      cp = vec3.direction [0 0 0] p
      cq = vec3.direction [0 0 0] q

      angle = Math.acos vec3.dot(cp, cq) / (vec3.length(cp) * vec3.length(cq))
      axis = vec3.cross cp, cq

      current-rot := mat4.rotate do
        mat4.identity!
        angle
        axis

      do draw

    &addEventListener \mousemove rotate

    stop = let ran = false
      !->
        if not ran
          ran = true

          mat4.multiply rotation, current-rot
          current-rot := mat4.identity!

        &style.cursor = \pointer
        &removeEventListener \mousemove rotate
        &removeEventListener \mouseup stop
        &removeEventListener \mouseleave stop

    &addEventListener \mouseup stop
    &addEventListener \mouseleave stop

