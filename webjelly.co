# Webjelly
# Author: Steven Ruppert
# For the Fall 2012 CSCI441 Graphics class at Colorado School of Mines

# this comment appears in the compiled source:
/* This file (webjelly.js) is compiled from webjelly.co. Please view the
original commented source there. */

"use strict"

canvas = document.getElementById \canvas
{width, height} = canvas

try
  window.gl = WebGLDebugUtils.makeDebugContext do
    canvas.getContext \webgl or canvas.getContext \experimental-webgl

if gl!?
  alert "Sorry, it looks like your browser doesn't support WebGL, or webGL is
    disabled!"
  throw new Error "no webgl ;_;"

# I don't like typing in gl all the time, so I will attach CONSTANTS to the
# global context. Don't do this at home, kids.
for k, v in gl
  window[k] = v if /^[A-Z_]+$/.test k

culling-face = FRONT

# set up
gl
  &viewport   0 0 width, height

  &disable    DEPTH_TEST

  &enable     CULL_FACE
  &cullFace   culling-face

  &clearColor 0 0 0 1 # black
  &clear      COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

# init the shader program
with gl
  vertex-shader = @createShader VERTEX_SHADER
    @shaderSource (&), """
      attribute vec3 coord;
      attribute vec3 normal;

      varying float NdotL;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;
      uniform mat3 NormalMatrix;
      uniform vec3 LightLocation;

      void main() {
        vec4 WorldCoord = ModelViewMatrix * vec4(coord,1.0);   // convert to world coordinates
        vec3 L = normalize(LightLocation - WorldCoord.xyz);    // L vector for illumination
        vec3 WorldNormal = NormalMatrix * normal;                // normal in world coordinates
        vec3 N = normalize(WorldNormal);                       // N vector for illumination
        NdotL = dot(N,L);                                      // part of diffuse term (multiplied by k_d's etc in the fragment shader)
        gl_Position = ProjectionMatrix * WorldCoord;             // gl_Position is a predefined variable
          // a correctly written vertex shader should write screen space coordinates to gl_Position
          // they are used on the rasterization stage!
      }
    """
    @compileShader (&)
    unless @getShaderParameter (&), COMPILE_STATUS
      throw new Error "couldn't compile vertex shader!"

  fragment-shader = @createShader FRAGMENT_SHADER
    @shaderSource (&), """
      precision mediump float;
      varying float NdotL;   // interpolated NdotL values (output of the vertex shader!)
      // note that interpolation qualifiers have to match between vertex and fragment shader

      uniform float LightIntensity;
      uniform float AmbientIntensity;
      uniform vec3 DiffuseAndAmbientCoefficient;     // for RGB: this is why it's a 3D vector

      void main() {
        gl_FragColor = vec4(
          (LightIntensity * (NdotL > 0.0 ? NdotL : 0.0) + AmbientIntensity) *
          DiffuseAndAmbientCoefficient,
          1);
        // note that some simplifying assumptions are made in the above formula
        //  for example, k_a=k_d is used; also, specular term is not used; also, no attenuation here
      }
    """
    @compileShader(&)
    unless @getShaderParameter (&), COMPILE_STATUS
      throw new Error "couldn't compile fragment shader!"

  window.program = @createProgram!
    @attachShader (&), vertex-shader
    @attachShader (&), fragment-shader
    @linkProgram (&)
    unless @getProgramParameter (&), LINK_STATUS
      throw new Error "couldn't intialize shader program!"
    @useProgram (&)

  # bind lightsource information

  @uniform1f do
    @getUniformLocation program, \LightIntensity
    0.9

  @uniform1f do
    @getUniformLocation program, \AmbientIntensity
    0.2

  @uniform3f do
    @getUniformLocation program, \DiffuseAndAmbientCoefficient
    1.0 1.0 1.0

  @uniform3f do
    @getUniformLocation program, \LightLocation
    200 200 200



degrees = -> it * 180 / Math.PI
radians = -> it * Math.PI / 180

calculate-normals = (triangles, vertices) ->
  n = new Float32Array vertices.length

  for i from 0 to triangles.length - 3 by 3
    a = triangles[i    ] * 3
    b = triangles[i + 1] * 3
    c = triangles[i + 2] * 3
    v0 = Array::slice.call vertices, a, 3 + a
    v1 = Array::slice.call vertices, b, 3 + b
    v2 = Array::slice.call vertices, c, 3 + c

    cross = vec3.cross do
      vec3.direction v0, v1, []
      vec3.direction v0, v2, []
      []

    n[a    ] += cross[0]
    n[a + 1] += cross[1]
    n[a + 2] += cross[2]

    n[b    ] += cross[0]
    n[b + 1] += cross[1]
    n[b + 2] += cross[2]

    n[c    ] += cross[0]
    n[c + 1] += cross[1]
    n[c + 2] += cross[2]

  return n

# draw the model from the input file of triangles and vertices
draw = !(triangles, vertices)->
  log triangles
  log vertices

  normals = calculate-normals triangles, vertices

  # find coordinate bounds
  minx = miny = minz = Infinity
  maxx = maxy = maxz = 0
  for i from 0 to vertices.length - 3 by 3
    vertices[i]
      minx <?= &
      maxx >?= &
    vertices[i + 1]
      miny <?= &
      maxy >?= &
    vertices[i + 2]
      minz <?= &
      maxz >?= &

  log "min: #minx #miny #minz"
  log "max: #maxx #maxy #maxz"

  # transforms to center stage
  to-center = -[(minx + maxx) / 2, (miny + maxy) / 2, (minz + maxz) / 2]
  to-stage =
    Math.max(maxx - minx, maxz - miny, maxz - minz) |> 2 / _ |> [_, _, _]
  #to-stage = [0.8, 0.8 , 0.8]

  console.log to-center
  console.log to-stage

  # set up and clear screen

  # vertices
  vertices-buffer = gl.createBuffer!
    gl.bindBuffer ARRAY_BUFFER, (&)
    gl.bufferData ARRAY_BUFFER, vertices, STATIC_DRAW

    # bind to varying coordiantes
    gl.getAttribLocation program, \coord
      gl.enableVertexAttribArray (&)
      gl.vertexAttribPointer (&), 3, FLOAT, false 0 0

  # normals
  normals-buffer = gl.createBuffer!
    gl.bindBuffer ELEMENT_ARRAY_BUFFER, (&)
    gl.bufferData ELEMENT_ARRAY_BUFFER, normals, STATIC_DRAW

    # bind to varying normal
    gl.getAttribLocation program, \normal
      gl.enableVertexAttribArray (&)
      gl.vertexAttribPointer (&), 3, FLOAT, false 0 0

  # elements
  triangles-buffer = gl.createBuffer!
    gl.bindBuffer ELEMENT_ARRAY_BUFFER, (&)
    gl.bufferData ELEMENT_ARRAY_BUFFER, triangles, STATIC_DRAW

  fov = 15degrees
  distance =  1 / Math.tan(radians(fov) / 2)

  console.log distance

  rotation = mat4.rotateZ do
    mat4.identity!
    radians(-225deg)

  # set matrix uniforms
  gl.uniformMatrix4fv do
    gl.getUniformLocation program, \ProjectionMatrix
    false
    mat4.perspective do
      fov
      1 # width / height
      log distance - 1
      log distance + 3

  gl.uniformMatrix3fv do
    gl.getUniformLocation program, \NormalMatrix
    false
    mat4.toMat3 rotation

  model-view = mat4.identity!
  log mat4.translate model-view, to-center
  #mat4.rotateY model-view, radians(-1.6deg)
  #mat4.rotateX model-view, radians(-1.6deg)
  mat4.multiply model-view, rotation
  mat4.translate model-view, [0,0, -(distance + 1)]
  mat4.scale model-view, to-stage

  gl.uniformMatrix4fv do
    gl.getUniformLocation program, \ModelViewMatrix
    false
    model-view

  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  gl.bindBuffer ELEMENT_ARRAY_BUFFER, triangles-buffer
  gl.drawElements TRIANGLES, triangles.length, UNSIGNED_SHORT, 0

log = -> console.log it; it

# read the input file
parse = !->
  if @files.0
    new FileReader
      &readAsText that
      &onload = !->
        tokens = @result.split /\s+/ .map parseFloat
        [num-triangles, num-vertices] = tokens.splice 0, 2

        draw do
          new Uint16Array tokens.splice 0 num-triangles * 3
          new Float32Array tokens.splice 0 num-vertices * 3

document.getElementById \file
  &addEventListener \change parse
  # on refresh, if some file is still selected, do parse
  parse.call (&)
