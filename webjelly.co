# Webjelly
# Author: Steven Ruppert
# For the Fall 2012 CSCI441 Graphics class at Colorado School of Mines

# this comment appears in the compiled source:
/* This file (webjelly.js) is compiled from webjelly.co. Please view the
original commented source there. */

"use strict"

canvas = document.getElementById \canvas
{width, height} = canvas

try
  window.gl = WebGLDebugUtils.makeDebugContext do
    canvas.getContext \webgl or canvas.getContext \experimental-webgl

if gl!?
  alert "Sorry, it looks like your browser doesn't support WebGL, or webGL is \
    disabled!"
  throw new Error "no webgl ;_;"

# I don't like typing in gl all the time, so I will attach CONSTANTS to the
# global context. Don't do this at home, kids.
for k, v in gl
  window[k] = v if /^[A-Z_]+$/.test k

# grab control state and setup listeners
var shading

$ \flat
  if &checked
    shading = \flat
  &addEventListener \click !->
    shading := \flat
    do flat-program
    do setup-buffers
    do draw

$ \gouraud
  if &checked
    shading = \gouraud
  &addEventListener \click !->
    shading := \gouraud
    do gouraud-program
    do setup-buffers
    do draw

# swap culling
$ \front
  if &checked
    gl.cullFace FRONT
  &addEventListener \click !->
    gl.cullFace FRONT
    do draw
$ \back
  if &checked
    gl.cullFace BACK
  &addEventListener \click !->
    gl.cullFace BACK
    do draw

# zooming
var fov
$ \zoom-in .addEventListener \click !->
  --fov
  do draw
$ \zoom-out .addEventListener \click !->
  ++fov
  do draw

# set up
gl
  &viewport   0 0 width, height

  &enable    DEPTH_TEST

  &enable     CULL_FACE

  &clearColor 0 0 0 1 # black
  &clear      COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

# OpenGL ES 2.0 doesn't support non-interpolating 'varying' variables in the shaders,
# so the only easy way to get flat shading is to not use a point light source.
flat-light-direction = vec3.normalize vec3.direction [-1,-1, 0] [0 0 5]

flat-program = shader-program gl,
  vertex: """
      attribute vec3 coord;
      attribute vec3 normal;

      varying float NdotL;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;
      uniform mat3 NormalMatrix;
      uniform vec3 L;

      void main() {
        vec4 WorldCoord = ModelViewMatrix * vec4(coord,1.0);   // convert to world coordinates
        vec3 WorldNormal = NormalMatrix * normal;                // normal in world coordinates
        vec3 N = normalize(WorldNormal);                       // N vector for illumination
        NdotL = dot(N,L);                                      // part of diffuse term (multiplied by k_d's etc in the fragment shader)
        gl_Position = ProjectionMatrix * WorldCoord;             // gl_Position is a predefined variable
          // a correctly written vertex shader should write screen space coordinates to gl_Position
          // they are used on the rasterization stage!
      }
  """
  fragment: """
      precision mediump float;

      varying float NdotL;   // interpolated NdotL values (output of the vertex shader!)

      uniform float LightIntensity;
      uniform float AmbientIntensity;
      uniform vec3 DiffuseAndAmbientCoefficient;     // for RGB: this is why it's a 3D vector

      void main() {
        gl_FragColor = vec4(
          (LightIntensity * (NdotL > 0.0 ? NdotL : 0.0) + AmbientIntensity) *
          DiffuseAndAmbientCoefficient,
          1);
        // note that some simplifying assumptions are made in the above formula
        //  for example, k_a=k_d is used; also, specular term is not used; also, no attenuation here
      }
    """
  init: !(gl, program) ->
    window.program = program
    # bind lightsource information

    @uniform1f do
      @getUniformLocation program, \LightIntensity
      0.9

    @uniform1f do
      @getUniformLocation program, \AmbientIntensity
      0.2

    @uniform3f do
      @getUniformLocation program, \DiffuseAndAmbientCoefficient
      1 1 1
      # 0.7 0.7 0.7

    @uniform3fv do
      @getUniformLocation program, \L
      flat-light-direction

gouraud-program = shader-program gl,
  vertex: """
      precision mediump float;

      attribute vec3 coord;
      attribute vec3 normal;

      varying vec3 aColor;

      uniform mat4 ModelViewMatrix;
      uniform mat4 ProjectionMatrix;
      uniform mat3 NormalMatrix;
      uniform vec3 LightLocation;

      uniform float LightIntensity;
      uniform float AmbientIntensity;
      uniform vec3 DiffuseAndAmbientCoefficient;

      void main() {
        vec4 WorldCoord = ModelViewMatrix * vec4(coord,1.0);
        vec3 L = normalize(LightLocation - WorldCoord.xyz);
        vec3 WorldNormal = NormalMatrix * normal;
        vec3 N = normalize(WorldNormal);
        float NdotL = dot(N,L);
        aColor =
          ((LightIntensity * (NdotL > 0.0 ? NdotL : 0.0) + AmbientIntensity) *
          DiffuseAndAmbientCoefficient);

        gl_Position = ProjectionMatrix * WorldCoord;
      }
    """
  fragment: """
      precision mediump float;

      varying vec3 aColor;

      void main() {
        gl_FragColor = vec4(aColor, 1.0);
        //  (LightIntensity * (NdotL > 0.0 ? NdotL : 0.0) + AmbientIntensity) *
         // DiffuseAndAmbientCoefficient,
         // 1);
      }
    """
  init: !(gl, program) ->
    window.program = program
    gl.uniform1f do
      gl.getUniformLocation program, \LightIntensity
      0.9

    gl.uniform1f do
      gl.getUniformLocation program, \AmbientIntensity
      0.2

    gl.uniform3f do
      gl.getUniformLocation program, \DiffuseAndAmbientCoefficient
      1 1 1
      # 0.7 0.7 0.7

    gl.uniform3fv do
      gl.getUniformLocation program, \LightLocation
      [-1 -1 -10]

var donut-texture
read \donut-texture, \AsBinaryString !->
  donut-texture := read-ppm gl, it

  do setup-buffers
  do reset-stage
  do draw

donut-program = shader-program gl,
  vertex: """
    \#define TWOPI #{2 * Math.PI}
    precision mediump float;

    attribute float theta;
    attribute float phi;

    varying vec2 tex;
    varying float intensity;

    uniform mat4 ModelViewMatrix;
    uniform mat4 ProjectionMatrix;
    uniform mat3 NormalMatrix;
    uniform vec3 LightLocation;

    uniform float LightIntensity;
    uniform float AmbientIntensity;
    uniform vec3 DiffuseAndAmbientCoefficient;

    void main() {
      vec3 coord = vec3( (0.75 + 0.25 * cos(phi)) * cos(theta)
                       , (0.75 + 0.25 * cos(phi)) * sin(theta)
                       , 0.25 * sin(phi)
                       );
      vec3 normal = vec3( -cos(phi) * cos(theta)
                        , -cos(phi) * sin(theta)
                        , -sin(phi)
                        );
      tex = vec2(theta/TWOPI,phi/TWOPI);

      vec4 WorldCoord = ModelViewMatrix * vec4(coord,1.0);
      vec3 L = normalize(LightLocation - WorldCoord.xyz);
      vec3 WorldNormal = NormalMatrix * normal;
      vec3 N = normalize(WorldNormal);
      float NdotL = dot(N,L);
      intensity =
        (LightIntensity * (NdotL > 0.0 ? NdotL : 0.0) + AmbientIntensity);

      gl_Position = ProjectionMatrix * WorldCoord;
    }
  """
  fragment: """
      precision mediump float;

      uniform sampler2D texture;

      varying vec2 tex; // coords
      varying float intensity;

      void main() {
        gl_FragColor = vec4(intensity * texture2D(texture, tex).xyz, 1.0);
      }
  """
  init: !(gl, program) ->
    window.program = program
    gl.uniform1f do
      gl.getUniformLocation program, \LightIntensity
      0.9

    gl.uniform1f do
      gl.getUniformLocation program, \AmbientIntensity
      0.1

    gl.uniform3fv do
      gl.getUniformLocation program, \LightLocation
      [-1 -1 -10]

var triangles, vertices
var vertices-buffer, normals-buffer, triangles-buffer
staging = mat4.identity!
var distance, rotation, current-rot
var gouraud, coords, flat

calculate-normals-and-flats = !->
  slice = Array::slice

  vert-norms = new Float32Array vertices.length

  # coord, with no duplicates
  coords := new Float32Array triangles.length * 3

  flat := new Float32Array triangles.length * 3
  j = 0

  for i from 0 til triangles.length by 3
    a = triangles[i    ] * 3
    b = triangles[i + 1] * 3
    c = triangles[i + 2] * 3
    v0 = slice.call vertices, a, 3 + a
    v1 = slice.call vertices, b, 3 + b
    v2 = slice.call vertices, c, 3 + c

    cross = vec3.cross do
      vec3.direction v0, v1, []
      vec3.direction v0, v2, []
      []

    vert-norms[a, a + 1, a + 2] += cross
    vert-norms[b, b + 1, b + 2] += cross
    vert-norms[c, c + 1, c + 2] += cross

    coords[j    , j + 1, j + 2] = v0
    coords[j + 3, j + 4, j + 5] = v1
    coords[j + 6, j + 7, j + 8] = v2

    flat[j    , j + 1, j + 2] = cross
    flat[j + 3, j + 4, j + 5] = cross
    flat[j + 6, j + 7, j + 8] = cross
    j += 9

  # fill gouraud normals in coords order
  j = 0
  gouraud := new Float32Array triangles.length * 3


  for i from 0 til triangles.length by 3
    a = triangles[i    ] * 3
    b = triangles[i + 1] * 3
    c = triangles[i + 2] * 3

    gouraud[j    , j + 1, j + 2] = slice.call vert-norms, a, 3 + a
    gouraud[j + 3, j + 4, j + 5] = slice.call vert-norms, b, 3 + b
    gouraud[j + 6, j + 7, j + 8] = slice.call vert-norms, c, 3 + c
    j += 9

  # find coordinate bounds
  minx = miny = minz = Infinity
  maxx = maxy = maxz = 0
  for i from 0 til vertices.length by 3
    vertices[i]
      minx <?= &
      maxx >?= &
    vertices[i + 1]
      miny <?= &
      maxy >?= &
    vertices[i + 2]
      minz <?= &
      maxz >?= &

  #log "min: #minx #miny #minz"
  #log "max: #maxx #maxy #maxz"

  # transforms to center stage
  to-center = -[(minx + maxx) / 2, (miny + maxy) / 2, (minz + maxz) / 2]
  to-stage =
    Math.max(maxx - minx, maxz - miny, maxz - minz)
    |> 2 / _
    |> [_, _, _]

  staging := mat4.identity!
  mat4.scale staging, to-stage
  mat4.translate staging, to-center

current-program = \donut
[thetas, phis] = do make-donut
var theta-buffer, phi-buffer

# draw the model from the input file of triangles and vertices
setup-buffers = !->
  if current-program is \donut
    do donut-program

    if donut-texture?
      gl.activeTexture gl.TEXTURE0
      gl.bindTexture gl.TEXTURE_2D, donut-texture
      gl.uniform1i do
        gl.getUniformLocation program, \texture
        0 # texture 0

    theta-buffer := gl.createBuffer!
      gl.bindBuffer ARRAY_BUFFER, (&)
      gl.bufferData do
        ARRAY_BUFFER
        thetas
        STATIC_DRAW

      # bind to varying coordiantes
      gl.getAttribLocation program, \theta
        gl.enableVertexAttribArray (&)
        gl.vertexAttribPointer (&), 1, FLOAT, false 0 0

    phi-buffer := gl.createBuffer!
      gl.bindBuffer ARRAY_BUFFER, (&)
      gl.bufferData do
        ARRAY_BUFFER
        phis
        STATIC_DRAW

      # bind to varying coordiantes
      gl.getAttribLocation program, \phi
        gl.enableVertexAttribArray (&)
        gl.vertexAttribPointer (&), 1, FLOAT, false 0 0
  else
    # vertices
    vertices-buffer := gl.createBuffer!
      gl.bindBuffer ARRAY_BUFFER, (&)
      gl.bufferData do
        ARRAY_BUFFER
        coords
        STATIC_DRAW

      # bind to varying coordiantes
      gl.getAttribLocation program, \coord
        gl.enableVertexAttribArray (&)
        gl.vertexAttribPointer (&), 3, FLOAT, false 0 0

    # normals
    normals-buffer := gl.createBuffer!
      gl.bindBuffer ARRAY_BUFFER, (&)
      gl.bufferData do
        ARRAY_BUFFER
        if shading is \flat then flat else gouraud
        STATIC_DRAW

      # bind to unvarying normal
      gl.getAttribLocation program, \normal
        gl.enableVertexAttribArray (&)
        gl.vertexAttribPointer (&), 3, FLOAT, false 0 0

    #triangles-buffer := gl.createBuffer!
      #gl.bindBuffer ELEMENT_ARRAY_BUFFER, (&)
      #gl.bufferData ELEMENT_ARRAY_BUFFER, triangles, STATIC_DRAW

reset-stage = !->
  rotation := mat4.identity!
  current-rot := mat4.identity!
  fov := 15deg
  distance := 1 / Math.tan(radians(fov) / 2)

export draw = !->
  gl.clear COLOR_BUFFER_BIT | DEPTH_BUFFER_BIT

  rot = mat4.multiply current-rot, rotation, mat4.create!

  gl.uniformMatrix4fv do
    gl.getUniformLocation program, \ProjectionMatrix
    false
    mat4.perspective fov, width / height, distance - 1, distance + 3

  # set matrix uniforms
  gl.uniformMatrix3fv do
    gl.getUniformLocation program, \NormalMatrix
    false
    mat4.toMat3 rot

  model-view = mat4.identity!
  mat4.translate model-view, [0,0, -(distance + 1)]
  mat4.multiply model-view, rot
  mat4.multiply model-view, staging

  gl.uniformMatrix4fv do
    gl.getUniformLocation program, \ModelViewMatrix
    false
    model-view

  #if shading is \gouraud
    #gl.bindBuffer ELEMENT_ARRAY_BUFFER, triangles-buffer
    #gl.drawElements TRIANGLES, triangles.length, UNSIGNED_SHORT, 0
  #else # flat
  if current-program is \donut
    gl.bindBuffer ARRAY_BUFFER, theta-buffer
    gl.drawArrays TRIANGLES, 0, thetas.length
  else
    gl.bindBuffer ARRAY_BUFFER, vertices-buffer
    gl.drawArrays TRIANGLES, 0, triangles.length

read \file, \AsText !->
  tokens = it.split /\s+/ .map parseFloat
  [num-triangles, num-vertices] = tokens.splice 0, 2

  triangles := new Uint16Array tokens.splice 0 num-triangles * 3
  vertices := new Float32Array tokens.splice 0 num-vertices * 3

  if shading is \flat
    do flat-program
  else
    do gouraud-program
  do calculate-normals-and-flats
  do setup-buffers
  do reset-stage
  do draw

point-under = (x,y) ->
  {left, top} = canvas.getBoundingClientRect!

  # normalize to [-1, 1]
  x = (x - left) * 2 / (width - 1) - 1
  y = -((y - top) * 2 / (height - 1) - 1)

  det = 1 - x*x - y*y

  if det >= 0
    [x, y, Math.sqrt det]
  else
    [x / Math.sqrt(x*x + y*y), y / Math.sqrt(x*x + y*y), 0]

# mouse rotation
canvas
  &addEventListener \mousedown !({clientX: i0, clientY: j0}) ->
    return unless current-rot?
    &style.cursor = \move

    p = point-under i0, j0

    rotate = !({clientX: i, clientY: j}) ->
      q = point-under i, j
      cp = vec3.direction [0 0 0] p
      cq = vec3.direction [0 0 0] q

      angle = Math.acos vec3.dot(cp, cq) / (vec3.length(cp) * vec3.length(cq))
      axis = vec3.cross cp, cq

      current-rot := mat4.rotate do
        mat4.identity!
        angle
        axis

      do draw

    &addEventListener \mousemove rotate

    stop = let ran = false
      !->
        if not ran
          ran := true

          mat4.multiply current-rot, rotation, rotation
          current-rot := mat4.identity!

        &style.cursor = \pointer
        &removeEventListener \mousemove rotate
        &removeEventListener \mouseup stop
        &removeEventListener \mouseleave stop

    &addEventListener \mouseup stop
    &addEventListener \mouseleave stop

