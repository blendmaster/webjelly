# Webjelly utility functions
# Author: Steven Ruppert
# For the Fall 2012 CSCI441 Graphics class at Colorado School of Mines

# this comment appears in the compiled source:
/* This file (utils.js) is compiled from utils.co. Please view the
original commented source there. */

"use strict"

# shorthand for applying translation to the identity
mat4.translation = (translation) ->
  mat4.translate mat4.identity!, translation

export log = -> console.log it; it

export degrees = -> it * 180 / Math.PI
export radians = -> it * Math.PI / 180

export $ = -> document.getElementById it

# flattens the 3d texture to a big 2d texture, since webGL doesn't support 3d
# textures natively
export flatten3d = (gl, pixels, width, height, depth) ->
  if width * height * depth > 2048*2048
    throw new Error "That 3d texture is too big ;_;"
  data = new Uint8Array pixels
  tex = gl.createTexture!
  gl.bindTexture gl.TEXTURE_2D, tex
  gl.texImage2D gl.TEXTURE_2D, 0, gl.RGB, 1, 1, 0, gl.RGB, gl.UNSIGNED_BYTE, data
  gl.texParameteri

# the texture from a ppm image file
export read-ppm = (gl, it) ->
  [p3, width, height, ...pixels] = it.split /\s+/
  data = new Uint8Array pixels
  tex = gl.createTexture!
  gl.bindTexture gl.TEXTURE_2D, tex

# how many vertices to generate with the donut around the circles
const
  RES    = 12vertices
  CIRCLE = Math.PI * 2
  RADS   = CIRCLE / RES

function mod n, b => ((n % b) + b) % b

# generates a torus model
# returns [thetas, phis] in Triangles order
export make-donut = ->
  thetas = new Float32Array RES * RES * 2 * 3
  phis   = new Float32Array RES * RES * 2 * 3
  i = 0; j = 0
  # for every point, add the two triangles in order
  for theta til CIRCLE by RADS
    for phi til CIRCLE by RADS
      #     3--1  .
      #      \ |
      #       \|
      #     . 2,4 .
      #        |\
      #        | \
      #     .  6--5
      thetas[i++] = theta                    ; phis[j++] = phi
      thetas[i++] = theta                    ; phis[j++] = mod phi + RADS, CIRCLE
      thetas[i++] = mod theta + RADS, CIRCLE ; phis[j++] = phi

      thetas[i++] = theta                    ; phis[j++] = mod phi + RADS, CIRCLE
      thetas[i++] = mod theta - RADS, CIRLCE ; phis[j++] = phi
      thetas[i++] = theta                    ; phis[j++] = mod phi + 2 * RADS, CIRCLE

# convert a sphere map to a cube map, which webGL can handle natively
# returns the cube map
export sphere-to-cube = (gl, sphere) ->
  return stuff

# from vertex and fragment glsl source, a function that attaches the program
# and runs initialization code provided
export shader-program = (gl, {vertex, fragment, init}) ->
  vertex-shader = gl.createShader gl.VERTEX_SHADER
    gl.shaderSource (&), vertex
    gl.compileShader (&)
    unless gl.getShaderParameter (&), COMPILE_STATUS
      throw new Error "couldn't compile vertex shader!\n#{gl.getShaderInfoLog(&)}"

  fragment-shader = gl.createShader gl.FRAGMENT_SHADER
    gl.shaderSource (&), fragment
    gl.compileShader (&)
    unless gl.getShaderParameter (&), COMPILE_STATUS
      throw new Error "couldn't compile fragment shader!\n#{gl.getShaderInfoLog(&)}"

  program = gl.createProgram!
    gl.attachShader (&), vertex-shader
    gl.attachShader (&), fragment-shader
    gl.linkProgram (&)
    unless gl.getProgramParameter (&), LINK_STATUS
      throw new Error "couldn't intialize shader program!"

  !->
    gl.useProgram program
    init gl, program

